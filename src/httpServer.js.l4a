{"type":"Reference","version":"0c252997f51d0cbe4f8989a694f4ae184deebcb5","content":"/*\n * # Lively4 Server -- a file server that serves and manages git repositories as REST\n *\n * ## Supported methods:\n * - GET\n * - PUT\n * - DELETE\n * - MKCOL\n * - OPTIONS\n *   - filelist\n *   - showversions\n *   - default: modified, type, name\n *\n * ## Special request HEADER\n * - fileversion\n */\n\nimport http from 'http';\nimport httpProxy from 'http-proxy';\nimport fs from 'fs';\nimport URL from 'url';\nimport Path from 'path';\nimport mime from 'mime';\nimport mkdirp from 'mkdirp';\nimport argv from 'argv';\nimport { exec } from 'child_process';\nimport slash from 'slash'; // Convert Windows backslash paths to slash paths: foo\\\\bar âž” foo/bar\nimport 'log-timestamp'; // // this adds a timestamp to all log messages\nimport * as utils from './utils.js';\nimport { cleanString, run, respondWithCMD } from './utils.js';\n\nimport Promise from 'bluebird'; // seems not to workd\n// e.g. this did not work var statFile = Promise.promisify(fs.stat);\n// var fs_exists = Prom.promisify(fs.exists);\n// but this does\n\nimport fetch from 'node-fetch';\n\nvar fs_exists = function(file) {\n  return new Promise(resolve =>\n    fs.exists(file, exists => {\n      resolve(exists); // there seems to be an issue here, so we do it very explictly\n    })\n  );\n};\n\nvar fs_stat = Promise.promisify(fs.stat);\nasync function try_fs_stat(file){\n  try {\n    return await fs_stat(file)\n  } catch(e) {\n    return null\n  }\n}\n\nvar fs_readdir = function(file) {\n  return new Promise(resolve => fs.readdir(file, resolve));\n};\n\nvar fs_writeFile = function(...args) {\n  return new Promise(resolve => fs.writeFile(args[0], args[1], args[2], (err) => resolve({err: err}) ))\n};\n\nvar fs_readFile = function(file) {\n  return new Promise((resolve, reject) => fs.readFile(file, \"utf8\", (err, data) => {\n    if (err) {\n      reject(err)\n    } else {\n      resolve(data)\n    }\n  }))\n};\n\n\nfs.readFile('/etc/passwd', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n\n// var readFile = Promise.promisify(fs.readFile);\n// var readDir = Promise.promisify(fs.readdir);\n\nexport function log(...args) {\n  console.log('[server]', ...args);\n}\n\n\n// #UseCase #ContextJS #AsyncContext it is really hard to hand down the request object into all methods, just so they can log properly...\nexport function logRequest(req, ...args) {\n  log(\"REQUEST[\" +req._logId + \"] \",...args);\n}\n\n\nconst Lively4bootfilelistName = \".lively4bootfilelist\"\nconst Lively4bundleName = \".lively4bundle.zip\"\nconst Lively4transpileDir = \".transpiled\"\nconst Lively4optionsDir = \".options\"\n\nconst GithubOriganizationMemberCache = {}\n\nvar RepositoryBootfiles = {}\n\nvar RepositoryInSync = {}; // cheap semaphore\nvar MakeInProgress = {}; // cheap semaphore\n\nvar breakOutRegex = new RegExp('/*\\\\/\\\\.\\\\.\\\\/*/');\nvar isTextRegEx = /\\.((txt)|(md)|(js)|(html)|(svg))$/;\n\nclass Server {\n  static get optionsSpec() {\n    return [\n      {\n        name: 'port',\n        short: 'p',\n        type: 'int',\n        description: 'port on which the server will listen for connections',\n        example:\n          \"'node httpServer.js -p 8001' or 'node httpServer.js --port=8001'\"\n      },\n      {\n        name: 'directory',\n        short: 'd',\n        type: 'path',\n        description: 'root directory from which the server will serve files',\n        example:\n          \"'node httpServer.js -d ../foo/bar' or node httpServer.js --directory=../foo/bar'\"\n      },\n      {\n        name: 'server',\n        type: 'path',\n        description: 'directory where the server looks for its scripts',\n        example: \"'node httpServer.js --server ~/lively4-server'\"\n      },\n      {\n        name: 'auto-commit',\n        type: 'boolean',\n        description: 'auto commit on every PUT file',\n        example: \"'node --auto-commit=true'\"\n      },\n      {\n        name: 'bash-bin',\n        type: 'string',\n        description: 'path to bash executable',\n        example: \"'node --bash-bin=\\\\cygwin64\\\\bin\\\\bash.exe'\"\n      },\n      {\n        name: 'lively4dir-unix',\n        type: 'string',\n        description: 'the directory in cygwin.'\n      },\n      {\n        name: 'authorize-requests',\n        type: 'boolean',\n        description: 'authorize every request by authenticating a user and checking if in github team'\n      },\n      {\n        name: 'github-organization',\n        type: 'string',\n        description: 'github organization'\n      },\n      {\n        name: 'github-team',\n        type: 'string',\n        description: 'github team'\n      },\n      {\n        name: 'myurl',\n        type: 'string',\n        description: 'myurl from the outside...'\n      }\n    ];\n  }\n\n  static setup() {\n    this.port = port;\n    this.server = server;\n  }\n\n  static get lively4dir() {\n    return lively4dir;\n  }\n\n  static set lively4dir(path) {\n    log('set lively4dir to:' + path);\n    sourceDir = path;\n    lively4dir = path;\n    lively4DirUnix = path;\n    return lively4dir;\n  }\n\n  static get autoCommit() {\n    return autoCommit;\n  }\n\n  static set autoCommit(bool) {\n    log('set autoCommit to: ' + bool);\n    return (autoCommit = bool);\n  }\n  \n\n  static start() {\n    log('Welcome to Lively4!');\n    log('Server: ' + this.server);\n    log('Lively4: ' + lively4dir);\n    log('Port: ' + this.port);\n    log('Auto-commit: ' + autoCommit);\n    log('Myurl: ' + Server.options.myurl);\n\n    this.tmpStorage = {};\n    this.requestCounter = 0\n    \n    \n    var proxy = httpProxy.createProxyServer({});\n\n    http\n      .createServer((req, res) => this.onRequest(req, res, proxy))\n      .listen(this.port, function(err) {\n        if (err) {\n          throw err;\n        }\n\n        log('Server running on port ' + port + ' in directory ' + sourceDir);\n      });\n  }\n\n  static setCORSHeaders(res) {\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.setHeader('Access-Control-Request-Method', '*');\n    res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET, DELETE, PUT');\n    res.setHeader('Access-Control-Allow-Headers', '*');\n  }\n\n  static async onRequest(req, res, proxy) {\n    req._logId = this.requestCounter++\n    req._startTime = Date.now()\n    logRequest(req, \"START \" + req.method + \"\\t\" + req.url)\n    try {\n      var debugInitiator = req.headers['debug-initiator'];\n      if (debugInitiator) {\n        logRequest(req, \"INITIATOR \" + debugInitiator)\n      }\n      var debugSession = req.headers['debug-session'];\n      if (debugSession) {\n        logRequest(req, \"SESSION \" + debugSession)\n      }\n\n      var debugSystem = req.headers['debug-system'];\n      if (debugSystem) {\n        logRequest(req, \"SYSTEM \" + debugSystem)\n      }\n\n      var startRequestTime = Date.now()\n\n\n      try {\n        this.setCORSHeaders(res);\n\n        // url =  new URL(\"https://lively-kernel.org/lively4/lively4-jens/src/client/boot.js\")\n        var url = URL.parse(req.url, true, false);\n        var pathname = url.pathname;// /lively4/lively4-jens/src/client/boot.js\n\n        pathname = pathname.replace(/['\";&?:#|]/g, ''); // just for safty\n\n        var path = decodeURI(slash(Path.normalize(pathname)));  // windows compat.....\n        var fileversion = req.headers['fileversion']; // \n\n        var m = path.match(/^\\/([^/]*)\\/(.*)/)\n\n\n\n        if (m) {\n          var repositorypath = Path.join(sourceDir, m[1]);\n          var filepath = m[2]\n        } else {\n          repositorypath = sourceDir\n          filepath = path\n        }\n\n\n        // log(\"authorize-requests: \" + this.options[\"authorize-requests\"])\n        if (this.options[\"authorize-requests\"]) {\n          // log(\"AUTH REQUIRED\")\n\n          var org = this.options[\"github-organization\"]\n          if (!org) { \n            logRequest(req,\"CONFIG ERROR: github-organization is missing\")\n          }\n          var teamName = this.options[\"github-team\"]\n          if (!teamName) { \n            logRequest(req, \"CONFIG ERROR: github-team is missing\")\n          }\n\n          var username = req.headers['gitusername'];\n          var password = req.headers['gitpassword'];\n\n          // log(\"user \" + username)\n          // log(\"password \" + (password + \"\").slice(0,3))\n\n          if (!username || !password) {\n            res.writeHead(403);\n            res.end('Please authenticate yourself\\n');\n            return;\n          }\n\n          // cache the authorization to go light on the github API and answer faster ourselves\n          var authorizationKey = org + \"/\" + org + \"/\" + username + \"/\" + password \n          var lastAuthorization = GithubOriganizationMemberCache[authorizationKey]\n          if (lastAuthorization && lastAuthorization.success) {\n            logRequest(req,\"AUTHORIZED BY CACHE\")\n            // do nothing\n          }  else {\n            logRequest(req,\"AUTHORIZATION required org: \" + org + \" team: \" + teamName)\n            let teamInfo = await fetch(`https://api.github.com/orgs/${org}/teams/${teamName}`, {\n              method: \"GET\",\n              headers: {\n                Authorization: \"token \" + password  \n              }\n            }).then(r => r.json());    \n\n            if (teamInfo.members_url) {\n              var members = await fetch(teamInfo.members_url.replace(/\\{.*/,\"\"), {\n                method: \"GET\",\n                headers: {\n                  Authorization: \"token \" + password  \n                }\n              }).then(r => r.json());\n              var userInTeam = members.map(ea => ea.login).includes(username)\n            } \n\n            if (!userInTeam) {\n              GithubOriganizationMemberCache[authorizationKey] = {\n                success: false,\n                time: Date.now(),\n                previous: lastAuthorization // for preventing... DoS attacks? #TODO\n              }\n              res.writeHead(403);\n              res.end('Authentification/Authorization failed\\n');\n              return;\n            }\n\n            GithubOriganizationMemberCache[authorizationKey] = {\n              success: true,\n              time: Date.now()\n            }\n          }\n        }\n\n        logRequest(req, `${req.method} ${path}  ${fileversion ? '[version= ' + fileversion + ']' : ''}`);\n        // logRequest(req, `repositorypath: ${repositorypath} filepath: ${filepath}`);\n\n        if (breakOutRegex.test(path) === true) {\n          res.writeHead(500);\n          res.end(\n            'Your not allowed to access files outside the pages storage area\\n'\n          );\n          return;\n        }\n\n        if (pathname.match(/\\/_tmp\\//)) {\n          return this.TMP(pathname, req, res);\n        }\n\n        if (pathname.match(/\\/_vq\\//)) {\n          return this.BP2019Proxy(pathname, req, res, proxy);\n        }\n\n        if (pathname.match(/\\/_github\\//)) {\n          req.url = req.url.replace('/_github/', '');\n          return proxy.web(req, res, { target: 'http://172.16.64.132:9001/' });\n        }\n        if (pathname.match(/\\/_meta\\//)) {\n          return this.META(pathname, req, res);\n        }\n        if (pathname.match(/\\/_webhook\\//)) {\n          return this.WEBHOOK(pathname, req, res);\n        }\n        if (path.match(/\\/_git.*/)) {\n          return this.GIT(path, req, res);\n        }\n        if (path.match(/\\/_graphviz.*/)) {\n          return this.GRAPHVIZ(path, req, res); // #TODO auth should be required \n        }\n        if (path.match(/\\/_make.*/)) {\n          return this.MAKE(path, req, res); // #TODO auth should be required\n        }\n        if (pathname.match(/\\/_search\\//)) {\n          return this.SEARCH(pathname, req, res);\n        }\n        if (req.method == 'GET') {\n          await  this.GET(repositorypath, filepath, fileversion, req, res);\n        } else if (req.method == 'PUT') {\n          await this.PUT(repositorypath, filepath, req, res);\n        } else if (req.method == 'DELETE') {\n          await  this.DELETE(repositorypath, filepath, res);\n        } else if (req.method == 'MKCOL') {\n          await this.MKCOL(repositorypath, filepath, res);\n        } else if (req.method == 'OPTIONS') {\n          await this.OPTIONS(repositorypath, filepath, req, res);\n        } else if (req.method == 'MOVE') {\n          await this.MOVE(repositorypath, filepath, req, res);\n        }\n      } catch (e) {\n        console.error('ERROR on request ' + req.url, e);\n        res.writeHead(500);\n        res.end('ERROR: ' + e);\n      }\n    } finally {\n      logRequest(req, \"FINISHED \" + req.method + \" (\"+ Math.round(Date.now() - startRequestTime) + \"ms) \" + req.url + \" \" )\n    }\n  }\n\n  static BP2019Proxy(pathname, req, res, proxy) {\n    \n    req.url = req.url.replace(/\\/_vq\\//, '');\n    return proxy.web(req, res, { target: 'http://localhost:10055/' });\n    \n    // res.writeHead(200);\n    //   res.end('Hey you wanted' + pathname);    \n  }\n\n  \n  static GET(repositorypath, filepath, fileversion, req, res) {\n    if (filepath.match(Lively4bundleName)) {\n      return this.ensureBundleFile(repositorypath, filepath, req, res);\n    } else if (fileversion && fileversion != 'undefined') {\n      return this.readFileVersion(repositorypath, filepath, fileversion, req, res);\n    } else {\n      return this.readFile(repositorypath, filepath, req, res);\n    }\n  }\n  \n  static hashFilepath(filepath) {\n    return filepath.replace(/\\//g,\"_\")\n  }\n  \n  static async ensureBundleFile(repositorypath, bundleFilepath, req, res) {\n    var bundleFile = Path.join(repositorypath, bundleFilepath)\n    if (!await fs_exists(bundleFile)) {\n      logRequest(req,\"CREATE BUNDLE for \" + repositorypath)\n      // #TODO pull file existence logic into javascript?\n      await this.ensureDirectory(repositorypath, Lively4optionsDir)\n      let optionsDir = Path.join(repositorypath, Lively4optionsDir)\n\n      await this.ensureDirectory(repositorypath, Lively4transpileDir)\n      let transpileDir = Path.join(repositorypath, Lively4transpileDir)\n\n      try {\n        var bootlist = await fs_readFile(repositorypath + \"/\" + Lively4bootfilelistName)\n      } catch(e) {\n        logRequest(req,\"WARNING, could not read \" + Lively4bootfilelistName + \":\" + e)\n      }\n      var relativeBootFiles = []\n      var relativeOptionFiles = []\n      var relativeTranspileFiles = []\n\n      if (bootlist) {\n        var hashed = new Map()\n        for(let file of bootlist.split(\"\\n\")) {\n\n          let filehash = this.hashFilepath(file)\n          // logRequest(req, \"filehash \" + filehash)\n          hashed.set(filehash, file)\n\n          let filepath = Path.join(repositorypath, file)\n\n          var stats = await try_fs_stat(filepath)\n          if (!stats) {\n            logRequest(req, \"ignore \" + filepath)\n            continue;\n          }\n          let optionsFile = Path.join(optionsDir, filehash)\n          let transpileFile = Path.join(transpileDir, filehash)\n          let transpileMapFile = Path.join(transpileDir, filehash + \".json.map\")\n\n          relativeBootFiles.push(file)\n\n          var optionsStats = await try_fs_stat(optionsFile)\n          if  (!optionsStats || stats.mtime > optionsStats.mtime ) {\n            var updatedOptions = await this.readOptions(repositorypath, filepath, stats)\n            logRequest(req, \"UPDATE OPTIONS \" + optionsFile)\n            await fs_writeFile(optionsFile, JSON.stringify(updatedOptions, null, 2))\n          }\n          relativeOptionFiles.push(Path.join(Lively4optionsDir, filehash)) \n\n          let transpileStats = await try_fs_stat(transpileFile)\n          if (transpileStats) {\n            if  (stats.mtime > transpileStats.mtime ){\n              logRequest(req, \"DELETE \" + transpileFile)\n              await this.deletePath(transpileFile)\n            } else {\n              relativeTranspileFiles.push(Path.join(Lively4transpileDir, filehash))\n            }          \n          }\n          let transpileMapStats = await try_fs_stat(transpileMapFile)\n          if (transpileMapStats) {\n            if  (stats.mtime > transpileMapStats.mtime ){\n              logRequest(req, \"DELETE \" + transpileMapFile)\n              await this.deletePath(transpileMapFile)\n            } else {\n              relativeTranspileFiles.push(Path.join(Lively4transpileDir, filehash  + \".json.map\"))\n\n            }\n          }\n        }\n\n        // DELETE not unused options/transpiled caches\n        // should not be needed, because.... it will not end up in zip anyway...\n\n        // for (let optionfile of fs.readdirSync(optionsDir)) {\n        //   if (!hashed.get(optionfile)) {\n        //     let filePath =  optionsDir + \"/\" +optionfile\n        //     logRequest(req, \"delete \" + filePath)\n        //     await this.deletePath(filePath)\n        //   } \n        // }\n        // for (let transpiledfile of fs.readdirSync(transpileDir)) {\n        //   let filePath =  transpileDir + \"/\" +transpiledfile\n        //   if (!hashed.get(transpiledfile)) {\n        //     logRequest(req, \"delete \" + transpileDir + \"/\" + transpiledfile)\n        //     await this.deletePath(filePath)\n        //   }\n        //   if (!hashed.get(transpiledfile.replace(/\\.json.map$/,\"\"))) {\n        //     logRequest(req, \"delete \" + transpileDir + \"/\" + transpiledfile)\n        //     await this.deletePath(filePath)\n        //   }\n        // }\n\n      }\n\n      let quoteList = function(list) {\n        return list.map(ea => `\"${ea}\"`).join(\" \")\n      }\n\n      var cmd = `cd ${repositorypath}; \n        if [ ! -e ${Lively4bundleName} ]; then\n          zip -r ${Lively4bundleName} ${quoteList(relativeBootFiles)} ${quoteList(relativeOptionFiles)} ${quoteList(relativeTranspileFiles)};\n        fi`\n      // logRequest(req, \"ZIP \" + cmd)\n      var result = await run(cmd)\n      // logRequest(req, \"stdout: \" + result.stdout + \"\\nstderr: \" + result.stderr)\n    }\n    return this.readFile(repositorypath, bundleFilepath, undefined, res)\n  }\n  \n  \n  \n  static async isInBootfile(repositorypath, filepath) {\n    console.log(\"isInBootfile \" + Lively4bootfilelistName + \" in \"+ repositorypath + \" \" + filepath)\n    if (filepath.match(Lively4bootfilelistName)) {\n      return true // the bootfilelist always invalidates itself...\n    }\n    \n    // costs... 10ms ... so #Refactor before using it every GET requests\n    var result = (await run(`cd ${repositorypath}; \n      echo ${Lively4bootfilelistName}\n      if [ -e ${Lively4bootfilelistName} ]; then\n        grep ${filepath} ${Lively4bootfilelistName}\n      fi`)).stdout      \n    return result.match(filepath)\n  }\n  \n  \n  /* load a specific version of a file through git */\n  static async readFileVersion(repositorypath, filepath, fileversion, req, res) {\n    var {stdout, stderr, error} = await run(\n      'cd ' + repositorypath + ';' + 'git show ' + fileversion + ':' + filepath,\n      res\n    );\n    var headers = {}\n    headers['Content-Type'] =  mime.lookup(filepath);\n    // console.log(\"[readfile version] stderr \" + stderr )\n    // console.log(\"[readfile version] err \", error == null )\n    \n    // ok, this is not easy to figure out\n    \n    // console.log(\"[readfile version] version \", fileversion )\n    \n    headers['fileversion'] =  fileversion;\n    \n    // not supported by git...\n    // headers['modified'] =   await this.getLastModified(repositorypath, filepath);\n\n    if (error == null) {\n      res.writeHead(200, headers);\n      res.end(stdout);\n    } else {\n      // console.log(\"ERROR ERROR 300\")\n      res.writeHead(300, headers);\n      res.end(stdout + stderr);\n    }\n  }\n  \n  \n  static async invalidateBundleFile(repositorypath, filepath) {\n    if (filepath.match(Lively4transpileDir) // all compiled files are bundled?\n        || await this.isInBootfile(repositorypath, filepath)) {\n      log(\"INVALIDATE \" + Lively4bundleName + \" in \"+ repositorypath)\n      // remove bundle if we uploaded a file that belongs into it\n      await this.deleteBundleFile(repositorypath)\n    } else {\n      log(\"NOTINBOOTFILE \" +  repositorypath + \" \" + filepath)\n    }\n  }\n\n  static async deleteBundleFile(repositorypath) {\n    return await run(`cd ${repositorypath}; \n      if [ -e ${Lively4bundleName} ]; then\n        rm ${Lively4bundleName}\n      fi`)\n  }  \n  \n  static async ensureDirectory(path, name) {\n    // #TODO do it directly in JavaScript instead of Polyglot?\n    var result = await run(`cd ${path}; \n      if [ ! -e ${name} ]; then\n        mkdir ${name}\n      fi`)\n    if (result.stderr) {\n      log(\"ensureDirectory stderr:\" + result.stderr)\n    }\n  }\n  \n  static async ensureSpecialParentDirectories(repositorypath, filepath, req) {\n    if (filepath.match(Lively4transpileDir)) { \n      await this.ensureDirectory(repositorypath, Lively4transpileDir)\n    }\n    \n    // if (filepath.match(Lively4optionsDir)) { \n    //   await this.ensureDirectory(repositorypath, Lively4optionsDir)\n    // }\n  }\n\n  static async invalidateOptionsFile(repositorypath, filepath, req) {\n    if (filepath.match(Lively4optionsDir)) return  // don't do it on yourself\n    if (!filepath.match(/\\.js/)) return  // only javascript files are transpiled...\n    \n    logRequest(req, \"invalidate options files\" + Lively4bundleName + \" in \"+ repositorypath)\n    var hashedpath = filepath.replace(/\\//g,\"_\")\n    await run(`cd ${repositorypath}; \n        if [[ -e ${Lively4optionsDir}/${hashedpath} ]]; then\n          rm ${Lively4optionsDir}/${hashedpath}\n        fi`)\n  }\n  \n  static async invalidateTranspiledFile(repositorypath, filepath, req) {\n    if (filepath.match(Lively4transpileDir)) return  // don't do it on yourself\n    if (!filepath.match(/\\.js/)) return  // only javascript files are transpiled...\n    \n    logRequest(req,\"invalidate transpilation files\" + Lively4bundleName + \" in \"+ repositorypath)\n    var hashedpath = filepath.replace(/\\//g,\"_\")\n    var result = await run(`cd ${repositorypath}; \n        if [ -e ${Lively4transpileDir} ]; then\n          rm ${Lively4transpileDir}/${hashedpath}\n          rm ${Lively4transpileDir}/${hashedpath}.map.json\n        fi`) \n    logRequest(req, \"RESULT \" + result.stdout)\n  }\n  \n  static async readFile(repositorypath, filepath, req, res) {\n    // logRequest(req, 'read based in:' + repositorypath + \" file: \" +filepath);\n    var fullpath = Path.join(repositorypath, filepath);\n    // throw new Error(\"hello error handler?\")\n\n    try {\n      // var stats = fs.statSync(filepath)\n      var stats = await fs_stat(fullpath);\n    } catch(e){\n      // nothing\n    }\n    \n    if (!stats) {\n      console.log('FILE DOES NOT EXIST ' + fullpath)\n      res.writeHead(404);\n      return res.end('File not found!\\n');\n    }\n    if (stats.isDirectory()) {\n      this.readDirectory(fullpath, req, res, 'text/html');\n    } else {\n      res.writeHead(200, {\n        'content-type': mime.lookup(fullpath),\n        fileversion: await this.getVersion(repositorypath, filepath),\n        modified: await this.getLastModified(repositorypath, filepath)\n      });\n      var stream = fs.createReadStream(fullpath, {\n        bufferSize: 64 * 1024\n      });\n      stream.on('error', function(err) {\n        log('error reading: ' + fullpath + ' error: ' + err);\n        res.end('Error reading file\\n');\n      });\n      stream.pipe(res);\n    }\n  }\n\n  static readDirectory(aPath, req, res, contentType) {\n    fs.readdir(aPath, function(err, files) {\n      var dir = {\n        type: 'directory',\n        contents: []\n      };\n\n      var checkEnd = () => {\n        // is there a better way for synchronization???\n        if (dir.contents.length === files.length) {\n          var data;\n          if (contentType == 'text/html') {\n            // prefix the directory itself as needed if it does not end in \"/\"\n            var match = req.url.match(/\\/([^/]+)$/); // aPath stripped the / already\n            var prefix = match ? match[1] + '/' : '';\n\n            \n            data =\n`<html><style>\n  body { \n    font-family: arial;\n  }\n </style><body><h1>` +\n              req.url +\n              '</h1>\\n<ul>' +\n              // '<!-- prefix=' +\n              // `PATH: ${aPath} PREFIX: ${prefix} URL: ${req.url} URL2: ${JSON.stringify(req.headers)}}` +\n              // ' -->' +\n              \n                \n              dir.contents.sort()\n                .map(ea => ea.name)\n                .sort()\n                .map(function(ea) {\n                  return (\n                    \"<li><a href='\" +\n                    prefix +\n                    ea +\n                    \"'>\" +\n                    ea +\n                    '</a></li>'\n                  );\n                })\n                .join('\\n') +\n              '</ul></body></html>';\n            \n            // github return text/plain, therefore we need to do the same\n            res.writeHead(200, {\n              'content-type': 'text/html'\n            });\n            res.end(data);\n          } else {\n            data = JSON.stringify(dir, null, 2);\n            // github return text/plain, therefore we need to do the same\n            res.writeHead(200, {\n              'content-type': 'text/plain'\n            });\n            res.end(data);\n          }\n        }\n      };\n      checkEnd();\n      files.forEach(function(filename) {\n        var filePath = Path.join(aPath, filename);\n        fs.stat(filePath, function(err, statObj) {\n          if (!statObj) {\n            dir.contents.push({\n              type: 'file',\n              name: filename,\n              size: 0\n            });\n          } else if (statObj.isDirectory()) {\n            dir.contents.push({\n              type: 'directory',\n              name: filename,\n              size: 0\n            });\n          } else {\n            dir.contents.push({\n              type: 'file',\n              name: filename,\n              size: statObj.size\n            });\n          }\n          checkEnd();\n        });\n      });\n    });\n  }\n\n  /*\n   * write file to disk\n   */\n  static async PUT(repositorypath, filepath, req, res) {\n    \n    var fullpath = Path.join(repositorypath, filepath);\n    var fullBody = '';\n    // if (filepath.match(/png$/)) {\n    if (filepath.match(isTextRegEx)) {\n      // #TODO how do we better decide if we need this...\n    } else {\n      logRequest(req, 'set binary encoding');\n      req.setEncoding('binary');\n    }\n    // }\n\n    //read chunks of data and store it in buffer\n    req.on('data', function(chunk) {\n      fullBody += chunk.toString();\n    });\n\n    await new Promise(resolve => req.on('end', resolve))\n    \n    //after transmission, write file to disk\n    \n    // only block at the end...\n    await this.invalidateOptionsFile(repositorypath, filepath, req)\n    await this.invalidateTranspiledFile(repositorypath, filepath, req,)\n    await this.invalidateBundleFile(repositorypath, filepath, req)\n    await this.ensureSpecialParentDirectories(repositorypath, filepath, req)\n\n    if (fullpath.match(/\\/$/)) {\n      return mkdirp(fullpath, err => {\n        if (err) {\n          logRequest(req, 'Error creating dir: ' + err);\n        }\n        logRequest(req, 'mkdir ' + fullpath);\n        res.writeHead(200, 'OK');\n        res.end();\n      });\n    } \n    var lastVersion = req.headers['lastversion'];\n    var currentVersion = await this.getVersion(repositorypath, filepath);\n\n    // logRequest(req, 'last version: ' + lastVersion);\n    // logRequest(req, 'current version: ' + currentVersion);\n\n    // we have version information and there is a conflict\n    if (lastVersion && currentVersion && lastVersion !== currentVersion) {\n      logRequest(req, '[writeFile] CONFLICT DETECTED');\n      res.writeHead(409, {\n        // HTTP CONFLICT\n        'content-type': 'text/plain',\n        conflictversion: currentVersion\n      });\n      res.end('Writing conflict detected: ' + currentVersion);\n      return;\n    }\n\n    // ogRequest(req, 'size ' + fullBody.length);\n    let result = await fs_writeFile(fullpath, fullBody, fullpath.match(isTextRegEx) ? undefined : 'binary')\n    if (result.err) {\n      // throw err;\n      logRequest(req, result.err);\n      throw new Error(\"Error in writeFile \" + fullpath, result.err)\n    }\n\n    if (!autoCommit || req.headers['nocommit'])  {\n      // logRequest(req, 'saved ' + fullpath);\n      res.writeHead(200, 'OK');\n      res.end();\n      return\n    } \n\n    var username = req.headers.gitusername;\n    var email = req.headers.gitemail;\n    // var password = req.headers.gitpassword; // not used yet\n\n    var authCmd = '';\n    if (username) authCmd += `git config user.name '${username}'; `;\n    if (email) authCmd += `git config user.email '${email}'; `;\n    // logRequest(req, 'EMAIL ' + email + ' USER ' + username);\n\n    // #TODO maybe we should ask for github credetials here too?\n    let cmd = `\n      cd \"${repositorypath}\"; \n      if [ -e .git ]; then\n        ${authCmd} git add \"${filepath}\"; \n        git commit -m \"AUTO-COMMIT ${filepath}\"\n      else\n        echo \"no git repository\" \n      fi\n    `;\n    {\n      let {error, stdout, stderr} = await run(cmd)\n      // logRequest(req, 'git stdout: ' + stdout);\n      // logRequest(req, 'git stderr: ' + stderr);\n      if (error) {\n        // file did not change....\n        if (!stdout.match(\"no changes added to commit\")) {\n          logRequest(req, 'ERROR');\n          res.writeHead(500, 'Error:' + stderr);\n          return res.end('ERROR stdout: ' + stdout + \"\\nstderr:\" + stderr);\n        }\n      } \n    }\n    var {options, body, error} = await this.ensureCachedOptions(repositorypath, filepath)\n    if (!options) {\n        res.writeHead(500);\n        res.end('could not retrieve new version... somthing went wrong: ' + error);\n    } else {\n      res.writeHead(200, {\n        'content-type': 'text/plain',\n        fileversion: options.version,\n      });\n      res.end(body);\n    }\n  }  \n  \n  static async ensureCachedOptions(repositorypath, filepath) {\n    console.log(\"ensureCachedOptions \" + repositorypath + \", \" + filepath )\n    let options = await this.readOptions(repositorypath, filepath)\n    if (options.error) {\n      return {options: null, body: null, error: options.error}\n    } else {\n      console.log(\"options: \" +  options )\n      var optionsBody = JSON.stringify(options, null, 2)\n      let optionsPath = this.optionsPath(repositorypath, filepath)\n      return {options, body: optionsBody, written: fs_writeFile(optionsPath, optionsBody)}\n    }\n  }\n\n  static optionsPath(repositorypath, filepath) {\n    return repositorypath + \"/\" + Lively4optionsDir + \"/\" + filepath.replace(/\\//g,\"_\") \n  }\n  \n  static transpilePath(repositorypath, filepath) {\n    return repositorypath + \"/\" + Lively4transpileDir + \"/\" + filepath.replace(/\\//g,\"_\") \n  }\n  \n  static async deletePath(fullpath) {\n    return run(\n      `f=\"${fullpath}\";\n      if [ -d \"$f\" ]; then rmdir -v \"$f\"; else rm -v \"$f\"; fi`)\n  }\n\n  /*\n   * delete file\n   */\n  static async DELETE(repositorypath, filepath, res) {\n    let fullpath = Path.join(repositorypath, filepath) \n\n    // clear all caches associated with the file\n    await this.deletePath(this.optionsPath(repositorypath, filepath))\n    await this.deletePath(this.transpilePath(repositorypath, filepath)) \n    \n    var result = await this.deletePath(fullpath)\n    if (result.error) {\n      res.writeHead(404)\n      return res.end(\"Error \" + result.stdout + \"\\n\" + result.stderr)\n    }    \n    res.writeHead(200)\n    res.end(\"deleted \" + fullpath)\n  }\n  \n   /*\n   * move file or directory\n   */\n  \n  static async moveResource(source, destination) {\n    return run(\n      `SOURCE=\"${source}\";\n       DESTINATION=\"${destination}\";\n       if [ -e $SOURCE -a -e $DESTINATION ]; \n          then mv $SOURCE $DESTINATION;\n       fi`)\n  }\n  \n  static async MOVE(repositorypath, filepath, req, res) {\n    \n    var source = req.url\n    \n    var destination = req.headers['destination']\n    \n    var re = new RegExp(Server.options.myurl + \"(.*)\")    \n    var m = destination.match(re)\n    \n    if (m) {\n      destination = m[1]\n    } else {\n      res.writeHead(404);\n      return res.end(\"Server for destination and source don't match!\")\n    }\n    \n    source = Server.options.directory + source.substr(1)\n    destination = Server.options.directory + destination\n    \n    var result = await this.moveResource(source, destination)\n    logRequest(req, 'MOVE from ' + source + ' to ' + destination)\n    \n    if (result.error) {\n      res.writeHead(404)\n      return res.end(\"Error \" + result.stdout + \"\\n\" + result.stderr)\n    }    \n    res.writeHead(200)\n    res.end(\"moved \" + source + \" to \" + destination)\n\n  }\n  \n  \n  /*\n   * create directory\n   */\n  static async MKCOL(repositorypath, filepath, res) {\n    let fullpath = Path.join(repositorypath, filepath) \n    // #TODO check for existing directory and return 409 ?\n    var result = await run(`mkdir -v \"${fullpath}\"`);\n    if (result.error) {\n      res.writeHead(404);\n      return res.end(\"Error \" + result.stdout + \"\\n\" + result.stderr);  \n    }\n    res.writeHead(200);\n    res.end(\"created directory: \" + fullpath);\n  }\n\n  static async readOptions(repositorypath, filepath, stats) {\n    var fullpath = Path.join(repositorypath, filepath)\n    if (!stats) {\n      try {\n        stats = await fs_stat(fullpath);\n      } catch(e) {\n        console.error(\"STATS error \" + filepath, e)\n        return JSON.stringify({error: e}, null, 2)\n      }\n    } \n    var result = { type: 'file' }\n    result.name = filepath\n    result.size = stats.size\n    result.version = await this.getVersion(repositorypath, filepath)  // PERFORMANCE WARNING\n    result.modified = await this.getLastModified(repositorypath, filepath) // PERFORMANCE WARNING\n    return result\n  }\n  \n  \n  /*\n   * list directory contents and file meta information\n   */\n  static async OPTIONS(repositorypath, filepath, req, res) {\n    var fullpath = Path.join(repositorypath, filepath)\n    logRequest(req, 'OPTIONS ' + fullpath)\n    var after = req.headers['gitafter']\n    var until = req.headers['gituntil']\n        \n    try {\n      var stats = await fs_stat(fullpath);\n    } catch(err) {\n      logRequest(req, 'stat ERROR: ' + err)\n      if (err.code == 'ENOENT') {\n        res.writeHead(200)\n        let data = JSON.stringify({error: err}, null, 2)\n        res.end(data)\n      } else {\n        logRequest(req, err)\n      }\n      return \n    }\n    if (stats.isDirectory()) {\n      if (req.headers['showversions'] == 'true') {\n        return this.listVersions(repositorypath, filepath, res, after, until);\n      }\n\n      if (req.headers['filelist'] == 'true') {\n        this.readFilelist(repositorypath, filepath, res);\n      } else {\n        this.readDirectory(fullpath, req, res);\n      }\n    } else if (stats.isFile()) {\n      if (req.headers['showversions'] == 'true') {\n        return this.listVersions(repositorypath, filepath, res, after, until);\n      }\n      let data = await this.readOptions(repositorypath, filepath, stats)\n      res.writeHead(200, {\n        'content-type': 'text/plain' // github return text/plain, therefore we need to do the same\n      });\n      res.end(JSON.stringify(data, null, 2))\n    }\n  }\n\n  /*\n   * recursively list directories and with modification date of files\n   * #Idea (should be used to update caches)\n   */\n  static async readFilelist(repositorypath, filepath, res) {\n    var result = await run(\n      `cd \"${repositorypath}/${filepath}\"; find -not -path '*/.git/*' -printf \"%TY-%Tm-%Td %TH:%TM:%.2TS\\t%y\\t%s\\t%p\\n\"`\n    );\n    var list = result.stdout\n      .split('\\n')\n      .map(line => {\n        var row = line.split('\\t');\n        return {\n          modified: row[0],\n          type: row[1] == 'd' ? 'directory' : 'file',\n          size: row[2],\n          name: row[3]\n        };\n      })\n      .filter(ea => ea.name && ea.name !== '.');\n    if (result.error) {\n      console.error(\"readFilelist stderr \" + result.stderr)\n      console.error(\"readFilelist: \" + result.error)\n    }\n    // console.log(\"readFilelist found \" + list.length + \" files\")\n    res.writeHead(200, {\n      'content-type': 'json'\n    });\n    res.end(\n      JSON.stringify({\n        type: 'filelist',\n        contents: list\n      })\n    );\n  }\n\n  static listVersions(repositorypath, filepath, res, after, until) {\n    // #TODO rewrite artificial json formatting and for example get rit of trailing \"null\"\n    var format =\n      '\\\\{\\\\\"version\\\\\":\\\\\"%h\\\\\",\\\\\"date\\\\\":\\\\\"%ad\\\\\",\\\\\"author\\\\\":\\\\\"%an\\\\\"\\\\,\\\\\"parents\\\\\":\\\\\"%p\\\\\",\\\\\"comment\\\\\":\\\\\"%f\\\\\"},';\n    \n    // #TODO #Security #Parameters?\n    var range = `${after ? '--after=\"' +after +'\"': \"\" } ${until ? '--until=\"' + until +'\"' : \"\"}`\n    \n    respondWithCMD(\n      `cd ${repositorypath};\n      echo \"{ \\\\\"versions\\\\\": [\";\n      git log --pretty=format:${format} ${range} ${filepath};\n      echo null\\\\]}`,\n      res\n    );\n  }\n\n  static META(pathname, req, res) {\n    if (pathname.match(/_meta\\/exit/)) {\n      res.end('goodbye, we hope for the best!');\n      process.exit();\n    } else {\n      res.writeHead(500);\n      res.end('meta: ' + pathname + ' not implemented!');\n    }\n  }\n\n  static async getVersion(repositorypath, filepath) {\n    return (await run(\n      `cd \"${repositorypath}\"; git log -n 1 --pretty=format:%H -- \"${filepath}\"`\n    )).stdout;\n  }\n\n  static async getLastModified(repositorypath, filepath) {\n    return (await run(\n      `cd \"${repositorypath}\"; find \"${filepath}\" -not -path '*/.git/*' -printf \"%TY-%Tm-%Td %TH:%TM:%.2TS\"`\n    )).stdout;\n  }\n\n  static async GIT(sPath, req, res, cb) {\n    logRequest(req, 'git control: ' + sPath);\n\n    var dryrun = req.headers['dryrun'];\n    dryrun = dryrun && dryrun == 'true';\n    // #TODO replace it with something more secure... #Security #Prototype\n    // Set CORS headers\n    var repository = req.headers['gitrepository'];\n    var repositoryurl = req.headers['gitrepositoryurl'];\n    var username = req.headers['gitusername'];\n    var password = req.headers['gitpassword'];\n    var email = req.headers['gitemail'];\n    var branch = req.headers['gitrepositorybranch'];\n    var msg = req.headers['gitcommitmessage'] && cleanString(req.headers['gitcommitmessage']);\n    var filepath = req.headers['gitfilepath'];\n    var gitcommit = req.headers['gitcommit'];\n    var usecolor = req.headers['gitusecolor'];\n\n    var versionA = req.headers['gitversiona'];\n    var versionB = req.headers['gitversionb'];\n    \n    var repositorypath = Path.join(sourceDir, repository)\n    \n    if (!email) {\n      return res.end('please provide email!');\n    }\n    if (!username) {\n      return res.end('please provide username');\n    }\n    if (!password) {\n      return res.end('please login');\n    }\n\n    if (!repository) {\n      return res.end('please specify repository');\n    }\n\n    repository = repository.replace(/^\\//,\"\") // #TODO should we take care of this in the client?\n    \n    var cmd;\n    if (sPath.match(/\\/_git\\/sync/)) {\n      logRequest(req, 'SYNC REPO ' + RepositoryInSync[repository]);\n      if (RepositoryInSync[repository]) {\n        return respondWithCMD(\n          'echo Sync in progress: ' + repository,\n          res,\n          dryrun\n        );\n      }\n      RepositoryInSync[repository] = true;\n      cmd = `${server}/bin/lively4sync.sh '${lively4DirUnix +\n        '/' +\n        repository}' '${username}' '${password}' '${email}' '${branch}' '${msg}'`;\n      await respondWithCMD(cmd, res, dryrun);\n      RepositoryInSync[repository] = undefined;\n      logRequest(req, \"delete bundle: \" + repositorypath)\n      await this.deleteBundleFile(repositorypath)\n    } else if (sPath.match(/\\/_git\\/resolve/)) {\n      cmd =\n        `${server}/bin/lively4resolve.sh '` +\n        lively4DirUnix +\n        '/' +\n        repository +\n        \"'\";\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/status/)) {\n      cmd = `cd ${lively4DirUnix}/${repository};\n        git -c color.status=always  status ; git log --color=always HEAD...origin/${branch} --pretty=\"format:%h\\t%aN\\t%cD\\t%f\"`;\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/log/)) {\n      cmd =\n        'cd ' + lively4DirUnix + '/' + repository + '; git log --color=always';\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/graph/)) {\n      cmd =\n        'cd ' +\n        lively4DirUnix +\n        '/' +\n        repository +\n        '; git log --graph -100 --color=always';\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/commit/)) {\n      if (!msg) {\n        return res.end('Please provide a commit message!');\n      }\n      cmd =\n        \"cd '\" +\n        lively4DirUnix +\n        '/' +\n        repository +\n        \"';\\n\" +\n        'git config user.name ' +\n        username +\n        ';\\n' +\n        'git config user.email ' +\n        email +\n        ';\\n' +\n        // \"git commit \"+ msg +\" -a \";\n        `if [ -e \".git/MERGE_HEAD\" ];\n        then\n          echo \"merge in progress - you had conflicts or a manual merge is in progress\";\n        else\n          git commit -m'${msg}' -a ;\n        fi`;\n\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/diff/)) {\n      var commit = 'origin/' + branch;\n      if (gitcommit) {\n        commit = gitcommit + '~1 ' + gitcommit;\n      }\n      cmd = `cd ${lively4DirUnix}/${repository}; git diff --color=always ${commit}`;\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/clone/)) {\n      let url = repositoryurl.replace(\"https://\", `https://${username}:${password}@`)\n      cmd =\n        `cd ${lively4DirUnix}; \\n` +\n        'git clone --recursive ' +\n        url +\n        ' ' +\n        repository +`;\\n` + // this will leave the password in the config\n        `cd ${lively4DirUnix}/${repository}; \\n` + \n        // #TODO can we avoid the and prevent the storing of username and password in the first place, e.g. is there is method of handing git the usename and password without encoding them in the url?\n        // remove the username password from the config       \n        `git remote set-url origin ${repositoryurl}` \n\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/checkout/)) {\n      \n      logRequest(req,'CHECKOUT REPO ' + RepositoryInSync[repository] + \" \" + filepath);\n      \n      // #TODO we should merge this semaphore logic...\n      if (RepositoryInSync[repository]) {\n        return respondWithCMD(\n          'echo Sync in progress: ' + repository,\n          res,\n          dryrun\n        );\n      }\n      RepositoryInSync[repository] = true;\n      // checkout single file directly from origin server... without pulling in other changes\n      // WARNING: the changes will appear as local changes but should be resolved by the merge later\n      // from git's standpoint it will appeach as two changes with the same content\n      let url = repositoryurl.replace(\"https://\", `https://${username}:${password}@`)\n      cmd = `cd ${lively4DirUnix}/${repository};\\n` + \n        `git remote set-url origin ${url};\\n` +\n        `git fetch; \\n` +\n        `git checkout origin/${branch} -- ${filepath}; \\n`+\n        `git remote set-url origin ${repositoryurl}` \n\n      await respondWithCMD(cmd, res, dryrun);\n      RepositoryInSync[repository] = undefined;\n    } else if (sPath.match(/\\/_git\\/npminstall/)) {\n      cmd = `cd ${lively4DirUnix}/${repository};\\n` + 'npm install';\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/npmtest/)) {\n      cmd = `cd ${lively4DirUnix}/${repository};\\n` + 'npm test';\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/remoteurl/)) {\n      cmd =\n        `cd ${lively4DirUnix}/${repository};\\n` +\n        'git config --get remote.origin.url';\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/branches$/)) {\n      cmd = `cd ${lively4DirUnix}/${repository};\\n` + 'git branch -a ';\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/branch$/)) {\n      cmd =\n        `${server}/bin/lively4branch.sh '${repository}' ` +\n        `'${username}' '${password}' '${email}' '${branch}'`;\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/merge$/)) {\n      cmd =\n        `${server}/bin/lively4merge.sh '${lively4DirUnix}/${repository}' ` +\n        `'${username}' '${password}' '${email}' '${branch}'`;\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/squash$/)) {\n      cmd =\n        `${server}/bin/lively4squash.sh '${lively4DirUnix}/${repository}' ` +\n        `'${username}' '${password}' '${email}' '${branch}' '${msg}'`;\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/delete$/)) {\n      cmd = `${server}/bin/lively4deleterepository.sh '${lively4DirUnix}/${repository}'`;\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/show$/)) {\n      cmd = `cd ${lively4DirUnix}/${repository};\\n` + `git show ${usecolor ? \" --color=always \" : \"\"}`  + gitcommit;\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/reset$/)) {\n      cmd = `cd ${lively4DirUnix}/${repository};\\n` + `git reset --hard origin/${branch}`;\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/mergebase$/)) {\n      cmd = `cd ${lively4DirUnix}/${repository};\\n` + `git merge-base ${versionA} ${versionB} `;\n      respondWithCMD(cmd, res, dryrun);\n    } else if (sPath.match(/\\/_git\\/reset-hard/)) {\n      cmd = `cd ${lively4DirUnix}/${repository};\\n` + `git checkout origin/gh-pages -- src/babylonian-programming-editor/demos/tree-improved.js.l4a`;\n      respondWithCMD(cmd, res, dryrun);\n    } else {\n      res.writeHead(200);\n      res.end('Lively4 git Control! ' + sPath + ' not implemented! :(');\n    }\n  }\n\n  static SEARCH(sPath, req, res) {\n    var pattern = req.headers['searchpattern'];\n    var rootdirs = req.headers['rootdirs'];\n    var excludes = '.git,' + req.headers['excludes'];\n\n    if (sPath.match(/\\/_search\\/files/)) {\n      var cmd = 'cd ' + lively4DirUnix + '; ';\n      cmd += 'find ' + rootdirs.replace(/,/g, ' ') + ' -type f ';\n      cmd += excludes\n        .split(',')\n        .map(function(ea) {\n          return ' -not -wholename \"*' + ea + '*\"';\n        })\n        .join(' ');\n      cmd +=\n        ' | while read file; do grep -H \"' +\n        pattern +\n        '\" \"$file\" ; done | cut -b 1-200';\n      return respondWithCMD(cmd, res);\n    } else {\n      res.writeHead(200);\n      res.end('Lively4 Search! ' + sPath + ' not implemented!');\n    }\n  }\n\n  /*\n   * Experimental in memory tmp file for drag and drop #Hack\n   */\n  static TMP(pathname, req, res) {\n    // log(\"tempFile \" + pathname)\n    var file = pathname.replace(/^\\/_tmp\\//, '');\n    if (req.method == 'GET') {\n      var data = this.tmpStorage[file];\n      res.writeHead(200);\n      res.end(data, 'binary');\n    }\n    if (req.method == 'PUT') {\n      var fullBody = '';\n      req.setEncoding('binary');\n      req.on('data', chunk => {\n        fullBody += chunk.toString();\n      });\n      req.on('end', async () => {\n        this.tmpStorage[file] = fullBody;\n        setTimeout(() => {\n          log('cleanup ' + file);\n          delete this.tmpStorage[file];\n        }, 5 * 60 * 1000); // cleanup after 5min\n        res.writeHead(200); // done\n        res.end();\n      });\n    }\n  }\n  \n  \n  static GRAPHVIZ(pathname, req, res) {\n    if (req.method == 'POST') {\n      var fullBody = '';\n      req.setEncoding('binary');\n      req.on('data', chunk => {\n        fullBody += chunk.toString();\n      });\n      req.on('end', async () => {\n        var tempFile = (await run(\"mktemp --suffix=.dot\")).stdout.replace(/\\n/g,\"\") \n        \n        // log(`got tmp file '${tempFile}'`)\n        await fs_writeFile(tempFile, fullBody)\n        // log(\"wrote tmp file\")\n        \n        var layout = \"dot\"\n        var type = \"svg\"\n        if (req.headers['graphlayout']) {\n          layout = cleanString(req.headers['graphlayout'])\n        }\n\n        \n        var result = (await run(`${layout} -T${type} '${tempFile}'`))\n        // log(`run dot '${ tempFile}'` )\n        \n        // log(\"deleted temp\")\n        await run(`rm '${tempFile}'`)\n        \n        var source = \"\" + result.stdout\n        if (source == \"\") {\n          logRequest(req, \"GraphViz ERR: \" + result.stderr)\n          res.writeHead(400); // done\n          res.end(result.stderr);          \n        } else {\n          res.writeHead(200); // done\n          res.end(source);          \n        } \n      });\n    }\n  }\n  \n  static MAKE(path, req, res) {\n    console.log(\"MAKE \" + path)\n    \n    var params = URL.parse(req.url, true).query\n    \n    // var cmd = 'cd ' + pathname + '; pwd;';\n    // MakeInProgress\n    var dir = path.replace(/.*_make\\//,\"\")\n      var cmd = 'cd ' + lively4DirUnix + '; ';\n    return respondWithCMD(\"cd \"  +lively4DirUnix + dir +\"; make \" + (params.target || \"\"),  res)\n    //return respondWithCMD(cmd, res)\n  }\n  \n  static webhookListeners(key) {\n    if (!this.webhookListeners) {\n      this.webhookListeners = new Map()\n    }\n    var set = this.webhookListeners[key]\n    if (!set) {\n      set = new Set()\n      this.webhookListeners[key] = set\n    }\n    return set\n  }\n  \n  \n  /* \n    Very basic forward of github webhooks to subscriptions...\n    see https://github.com/LivelyKernel/lively4-core/settings/hooks\n  */\n  static async WEBHOOK(pathname, req, res) {\n    log(\"WEBHOOK \" + req.method + \": \" + pathname)\n    \n    if (req.method == 'GET' && pathname.match(\"/_webhook/register\")) {\n      let key =  req.headers['repositoryname']; \n      log(\"webhook register \" + key)\n      \n      this.webhookListeners(key).add({\n        response: res\n      })\n      // do not answer it... do a long poll\n      \n      // res.writeHead(200); // done\n      // res.end();\n\n    } else if((req.method == 'PUT' || req.method == 'POST') && pathname.match(\"/_webhook/signal\")) {\n   \n      log(\"webhook signal \")\n      var body = '';\n      req.on('data', (data) => {\n          body += data;\n      });\n      req.on('end', () => {\n\n        try {\n          var json = JSON.parse(body)\n        } catch(e) {  \n          res.writeHead(400); // done\n          res.end(\"could not parse: \" + body);\n        }\n        if (json) {\n          var key = json.repository.full_name\n          var listeners = this.webhookListeners(key)\n          // log(\"found listeners: \" + listeners.size)\n          Array.from(listeners).forEach(ea => {\n            var response = ea.response\n            if (response) {\n              // log(\"answer \" + response)\n              response.writeHead(200); // answer long poll \n              response.end(JSON.stringify(json));              \n            }\n            listeners.delete(ea)\n          })\n          res.writeHead(200); // done\n          res.end(\"\");  \n        }\n      });      \n    } else {\n      log(\"webhook: \" + pathname)\n      res.writeHead(200); // not \n      res.end();\n    }    \n  }\n  \n  \n}\n\n// #REFACTOR\n// parse command line arguments\nvar args = argv.option(Server.optionsSpec).run();\nServer.options = args.options\nvar port = args.options.port || 8080;\nvar sourceDir = args.options.directory || '../';\nvar indexFiles = args.options['index-files'];\nvar lively4dir = sourceDir;\nvar server = args.options.server || '.';\nvar bashBin = args.options['bash-bin'] || 'bash';\nutils.config.bashBin = bashBin;\nvar lively4DirUnix = args.options['lively4dir-unix'] || lively4dir;\nvar autoCommit = args.options['auto-commit'] || false;\n\n// Does this work?\n// process.on('uncaughtException', function(error) {\n//   console.log(\"uncaughtException: \" + error)\n//   process.exit(1)\n// });\n// process.on('unhandledRejection', function(reason, p){\n//   console.log(\"unhandledRejection: \" + reason)\n// });\n\nServer.setup();\n\nif (!module.parent) {\n  Server.start();\n}\n\nmodule.exports = Server; // { start }\n"}
{"0":"'","1":"n","2":"o","3":"d","4":"e","5":" ","6":"h","7":"t","8":"t","9":"p","10":"S","11":"e","12":"r","13":"v","14":"e","15":"r","16":".","17":"j","18":"s","19":" ","20":"-","21":"p","22":" ","23":"8","24":"0","25":"0","26":"1","27":"'","28":" ","29":"o","30":"r","31":" ","32":"'","33":"n","34":"o","35":"d","36":"e","37":" ","38":"h","39":"t","40":"t","41":"p","42":"S","43":"e","44":"r","45":"v","46":"e","47":"r","48":".","49":"j","50":"s","51":" ","52":"-","53":"-","54":"p","55":"o","56":"r","57":"t","58":"=","59":"8","60":"0","61":"0","62":"1","63":"'","from":0,"to":0}
{"0":"'","1":"n","2":"o","3":"d","4":"e","5":" ","6":"h","7":"t","8":"t","9":"p","10":"S","11":"e","12":"r","13":"v","14":"e","15":"r","16":".","17":"j","18":"s","19":" ","20":"-","21":"d","22":" ","23":".","24":".","25":"/","26":"f","27":"o","28":"o","29":"/","30":"b","31":"a","32":"r","33":"'","34":" ","35":"o","36":"r","37":" ","38":"n","39":"o","40":"d","41":"e","42":" ","43":"h","44":"t","45":"t","46":"p","47":"S","48":"e","49":"r","50":"v","51":"e","52":"r","53":".","54":"j","55":"s","56":" ","57":"-","58":"-","59":"d","60":"i","61":"r","62":"e","63":"c","64":"t","65":"o","66":"r","67":"y","68":"=","69":".","70":".","71":"/","72":"f","73":"o","74":"o","75":"/","76":"b","77":"a","78":"r","79":"'","from":0,"to":0}